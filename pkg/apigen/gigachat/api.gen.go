// Package apigen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package apigen

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Базовая_аутентификацияScopes = "Базовая_аутентификация.Scopes"
	Токен_доступаScopes          = "Токен_доступа.Scopes"
)

// Defines values for BatchResponseMethod.
const (
	BatchResponseMethodChatCompletions BatchResponseMethod = "chat_completions"
	BatchResponseMethodEmbedder        BatchResponseMethod = "embedder"
)

// Defines values for BatchResponseStatus.
const (
	BatchResponseStatusCompleted  BatchResponseStatus = "completed"
	BatchResponseStatusCreated    BatchResponseStatus = "created"
	BatchResponseStatusInProgress BatchResponseStatus = "in_progress"
)

// Defines values for BatchesListBatchesMethod.
const (
	BatchesListBatchesMethodChatCompletions BatchesListBatchesMethod = "chat_completions"
	BatchesListBatchesMethodEmbedder        BatchesListBatchesMethod = "embedder"
)

// Defines values for BatchesListBatchesStatus.
const (
	BatchesListBatchesStatusCompleted  BatchesListBatchesStatus = "completed"
	BatchesListBatchesStatusCreated    BatchesListBatchesStatus = "created"
	BatchesListBatchesStatusInProgress BatchesListBatchesStatus = "in_progress"
)

// Defines values for ChoicesFinishReason.
const (
	Blacklist    ChoicesFinishReason = "blacklist"
	Error        ChoicesFinishReason = "error"
	FunctionCall ChoicesFinishReason = "function_call"
	Length       ChoicesFinishReason = "length"
	Stop         ChoicesFinishReason = "stop"
)

// Defines values for FileAccessPolicy.
const (
	Private FileAccessPolicy = "private"
	Public  FileAccessPolicy = "public"
)

// Defines values for FilePurpose.
const (
	FilePurposeGeneral FilePurpose = "general"
)

// Defines values for FileUploadPurpose.
const (
	FileUploadPurposeGeneral FileUploadPurpose = "general"
)

// Defines values for FunctionValidationResultMessage.
const (
	FunctionIsValid         FunctionValidationResultMessage = "Function is valid"
	IncorrectFunctionSyntax FunctionValidationResultMessage = "Incorrect function syntax"
)

// Defines values for MessagesResRole.
const (
	MessagesResRoleAssistant          MessagesResRole = "assistant"
	MessagesResRoleFunctionInProgress MessagesResRole = "function_in_progress"
)

// Defines values for AiCheckModel.
const (
	GigaCheckClassification AiCheckModel = "GigaCheckClassification"
	GigaCheckDetection      AiCheckModel = "GigaCheckDetection"
)

// Defines values for AiCheckResponseCategory.
const (
	Ai    AiCheckResponseCategory = "ai"
	Human AiCheckResponseCategory = "human"
	Mixed AiCheckResponseCategory = "mixed"
)

// Defines values for FunctionCallNoneAuto.
const (
	Auto FunctionCallNoneAuto = "auto"
	None FunctionCallNoneAuto = "none"
)

// Defines values for MessageRole.
const (
	MessageRoleAssistant MessageRole = "assistant"
	MessageRoleFunction  MessageRole = "function"
	MessageRoleSystem    MessageRole = "system"
	MessageRoleUser      MessageRole = "user"
)

// Defines values for PostBatchesParamsMethod.
const (
	ChatCompletions PostBatchesParamsMethod = "chat_completions"
	Embedder        PostBatchesParamsMethod = "embedder"
)

// Defines values for PostTokenFormdataBodyScope.
const (
	GIGACHATAPIB2B  PostTokenFormdataBodyScope = "GIGACHAT_API_B2B"
	GIGACHATAPICORP PostTokenFormdataBodyScope = "GIGACHAT_API_CORP"
	GIGACHATAPIPERS PostTokenFormdataBodyScope = "GIGACHAT_API_PERS"
)

// Balance defines model for Balance.
type Balance struct {
	Balance *[]struct {
		// Usage Название модели, например, GigaChat или embeddings.
		Usage *string `json:"usage,omitempty"`

		// Value Остаток токенов.
		Value *int `json:"value,omitempty"`
	} `json:"balance,omitempty"`
}

// BatchResponse defines model for BatchResponse.
type BatchResponse struct {
	// CreatedAt Время создания файла в формате unix timestamp.
	CreatedAt *int `json:"created_at,omitempty"`

	// Id Идентификатор созданной пакетной задачи.
	Id *string `json:"id,omitempty"`

	// Method Имя метода, в который пойдет запрос на выполнение.
	Method *BatchResponseMethod `json:"method,omitempty"`

	// RequestCounts Количество запросов внутри пакетной задачи.
	RequestCounts *map[string]interface{} `json:"request_counts,omitempty"`

	// Status Статус обработки пакетной задачи.
	Status *BatchResponseStatus `json:"status,omitempty"`

	// UpdatedAt Время обновления файла в формате unix timestamp.
	UpdatedAt *int `json:"updated_at,omitempty"`
}

// BatchResponseMethod Имя метода, в который пойдет запрос на выполнение.
type BatchResponseMethod string

// BatchResponseStatus Статус обработки пакетной задачи.
type BatchResponseStatus string

// BatchesList defines model for BatchesList.
type BatchesList struct {
	// Batches Список пакетных задач.
	Batches *[]struct {
		// CreatedAt Время создания файла в формате unix timestamp.
		CreatedAt *int `json:"created_at,omitempty"`

		// Id Идентификатор созданной пакетной задачи.
		Id *string `json:"id,omitempty"`

		// Method Имя метода, в который далее пойдет запрос на выполнение.
		Method *BatchesListBatchesMethod `json:"method,omitempty"`

		// OutputFileId Идентификатор файла с  результатами обработки запросов батча. Заполняется, если status = completed. Cкачать результат можно с помощью метода `get file/{file_id}/content`.
		OutputFileId *string `json:"output_file_id,omitempty"`

		// RequestCounts Количество запросов внутри пакетной задачи.
		RequestCounts *map[string]interface{} `json:"request_counts,omitempty"`

		// Status Статус обработки файла.
		Status *BatchesListBatchesStatus `json:"status,omitempty"`

		// UpdatedAt Время обновления файла в формате unix timestamp.
		UpdatedAt *int `json:"updated_at,omitempty"`
	} `json:"batches,omitempty"`
}

// BatchesListBatchesMethod Имя метода, в который далее пойдет запрос на выполнение.
type BatchesListBatchesMethod string

// BatchesListBatchesStatus Статус обработки файла.
type BatchesListBatchesStatus string

// Chat defines model for Chat.
type Chat struct {
	// FunctionCall Явно задает [режим работы с функциями](/ru/gigachat/guides/functions/function-calling-modes).
	// Может быть строкой или объектом.
	//
	// Возможные значения:
	//
	// * `none` — модель не будет вызывать встроенные функции или генерировать аргументы для пользовательских функций, а просто сгенерирует ответ в соответствии с полученными сообщениями;
	//
	// * `auto` — в авторежиме модель, основываясь на тексте сообщений, решает нужно ли использовать одну из [встроенных функций](/ru/gigachat/guides/functions/calling-builtin-functions) или сгенерировать аргументы для пользовательских функций, описанных в массиве `functions`. При этом, если массив содержит описание хотя бы одной пользовательской функции, модель сможет вызвать встроенную функцию, только если ее название передано в массиве `functions`;
	//
	//   ```json
	//   {
	//   	"function_call": "auto",
	//     "functions": [
	//   	  {
	//           "name": "text2image"
	//   	  },
	//       {
	//           "name": "weather_forecast",
	//           "description": "Возвращает температуру на заданный период",
	//           "parameters": {}
	//       }
	//     ]
	//   }
	//   ```
	//
	// * `{"name": "название_функции"}` — принудительная генерация аргументов для указанной функции. При принудительной генерации аргументов для пользовательской функции ее описание нужно обязательно передавать в массиве `functions`.
	// В противном случае вернется ошибка.
	FunctionCall *Chat_FunctionCall `json:"function_call,omitempty"`

	// Functions Массив с описанием пользовательских функций.
	Functions *CustomFunctions `json:"functions"`

	// MaxTokens Максимальное количество токенов, которые будут использованы для создания ответов.
	MaxTokens *int32 `json:"max_tokens"`

	// Messages Массив сообщений, которыми пользователь обменивался с моделью.
	//
	// В запросе можно передать только один системный промпт (сообщение с ролью `system`).
	// Системный промпт должен быть первым сообщением в массиве.
	//
	// Наличие в массиве нескольких системных промптов или передача системного промпта не в первом сообщении приведет к ошибке [с кодом 422](/ru/gigachat/api/errors-description?responseCode=422) и сообщением `Invalid params: system message must be the first message`.
	Messages []Message `json:"messages"`

	// Model Model ID
	Model string `json:"model"`

	// RepetitionPenalty Количество повторений слов:
	//
	// * Значение 1.0 — нейтральное значение.
	// * При значении больше 1 модель будет стараться не повторять слова.
	//
	// Значение по умолчанию зависит от выбранной модели (поле `model`) и может изменяться с обновлениями модели.
	RepetitionPenalty *float32 `json:"repetition_penalty"`

	// Stream Указывает что сообщения надо передавать по частям в потоке.
	//
	// Сообщения передаются по протоколу [SSE](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format).
	//
	// Поток завершается событием `data: [DONE]`.
	//
	// Подробнее читайте в разделе [Потоковая генерация токенов](/ru/gigachat/guides/response-token-streaming).
	Stream *bool `json:"stream,omitempty"`

	// Temperature Температура выборки. Чем выше значение, тем более случайным будет ответ модели. Если значение температуры находится в диапазоне от 0 до 0.001, параметры `temperature` и `top_p` будут сброшены в режим, обеспечивающий максимально детерминированный (стабильный) ответ модели. При значениях температуры больше двух, набор токенов в ответе модели может отличаться избыточной случайностью.
	//
	// Значение по умолчанию зависит от выбранной модели (поле `model`) и может изменяться с обновлениями модели.
	Temperature *float32 `json:"temperature"`

	// TopP Параметр используется как альтернатива температуре (поле `temperature`). Задает вероятностную массу токенов, которые должна учитывать модель.
	// Так, если передать значение 0.1, модель будет учитывать только токены, чья вероятностная масса входит в верхние 10%.
	//
	// Значение по умолчанию зависит от выбранной модели (поле `model`) и может изменяться с обновлениями модели.
	//
	// Значение изменяется в диапазоне от 0 до 1 включительно.
	TopP *float32 `json:"top_p"`

	// UpdateInterval Параметр потокового режима (`"stream": "true"`).
	// Задает минимальный интервал в секундах, который проходит между отправкой токенов.
	// Например, если указать `1`, сообщения будут приходить каждую секунду, но размер каждого из них будет больше, так как за секунду накапливается много токенов.
	UpdateInterval *float32 `json:"update_interval,omitempty"`
}

// Chat_FunctionCall Явно задает [режим работы с функциями](/ru/gigachat/guides/functions/function-calling-modes).
// Может быть строкой или объектом.
//
// Возможные значения:
//
// * `none` — модель не будет вызывать встроенные функции или генерировать аргументы для пользовательских функций, а просто сгенерирует ответ в соответствии с полученными сообщениями;
//
// * `auto` — в авторежиме модель, основываясь на тексте сообщений, решает нужно ли использовать одну из [встроенных функций](/ru/gigachat/guides/functions/calling-builtin-functions) или сгенерировать аргументы для пользовательских функций, описанных в массиве `functions`. При этом, если массив содержит описание хотя бы одной пользовательской функции, модель сможет вызвать встроенную функцию, только если ее название передано в массиве `functions`;
//
//	```json
//	{
//		"function_call": "auto",
//	  "functions": [
//		  {
//	        "name": "text2image"
//		  },
//	    {
//	        "name": "weather_forecast",
//	        "description": "Возвращает температуру на заданный период",
//	        "parameters": {}
//	    }
//	  ]
//	}
//	```
//
// * `{"name": "название_функции"}` — принудительная генерация аргументов для указанной функции. При принудительной генерации аргументов для пользовательской функции ее описание нужно обязательно передавать в массиве `functions`.
// В противном случае вернется ошибка.
type Chat_FunctionCall struct {
	union json.RawMessage
}

// ChatCompletion defines model for ChatCompletion.
type ChatCompletion struct {
	// Choices Массив ответов модели.
	Choices *[]Choices `json:"choices,omitempty"`

	// Created Дата и время создания ответа в формате unix timestamp.
	Created *int `json:"created,omitempty"`

	// Model Model ID
	Model *string `json:"model,omitempty"`

	// Object Название вызываемого метода.
	Object *string `json:"object,omitempty"`

	// Usage Данные об использовании модели.
	// При запуске [потоковой генерации](/ru/gigachat/guides/response-token-streaming), объект приходит в предпоследнем событии.
	Usage *Usage `json:"usage,omitempty"`
}

// Choices defines model for Choices.
type Choices struct {
	// FinishReason Причина завершения гипотезы. Возможные значения:
	//
	// * `stop` — модель закончила формировать гипотезу и вернула полный ответ;
	// * `length` — достигнут лимит токенов в сообщении;
	// * `function_call` — указывает, что при запросе была вызвана встроенная функция или сгенерированы аргументы для пользовательской функции;
	// * `blacklist` — запрос попадает под [тематические ограничения](/ru/gigachat/limitations#tematicheskie-ogranicheniya-zaprosov).
	// * `error` — ответ модели содержит невалидные аргументы пользовательской функции.
	//
	// При работе в режиме [потоковой генерации](/ru/gigachat/guides/response-token-streaming) передается в предпоследнем событии со значением.
	FinishReason *ChoicesFinishReason `json:"finish_reason,omitempty"`

	// Index Индекс сообщения в массиве, начиная с ноля.
	Index *int32 `json:"index,omitempty"`

	// Message Сгенерированное сообщение.
	Message *MessagesRes `json:"message,omitempty"`
}

// ChoicesFinishReason Причина завершения гипотезы. Возможные значения:
//
// * `stop` — модель закончила формировать гипотезу и вернула полный ответ;
// * `length` — достигнут лимит токенов в сообщении;
// * `function_call` — указывает, что при запросе была вызвана встроенная функция или сгенерированы аргументы для пользовательской функции;
// * `blacklist` — запрос попадает под [тематические ограничения](/ru/gigachat/limitations#tematicheskie-ogranicheniya-zaprosov).
// * `error` — ответ модели содержит невалидные аргументы пользовательской функции.
//
// При работе в режиме [потоковой генерации](/ru/gigachat/guides/response-token-streaming) передается в предпоследнем событии со значением.
type ChoicesFinishReason string

// CustomFunction Описание пользовательской функции.
type CustomFunction struct {
	// Description Текстовое описание функции.
	Description *string `json:"description,omitempty"`

	// FewShotExamples Объекты с парами `запрос_пользователя`-`параметры_функции`, которые будут служить модели примерами ожидаемого результата.
	FewShotExamples *[]struct {
		// Params Пример заполнения параметров пользовательской функции.
		Params map[string]interface{} `json:"params"`

		// Request Запрос пользователя.
		Request string `json:"request"`
	} `json:"few_shot_examples,omitempty"`

	// Name Название пользовательской функции, для которой будут сгенерированы аргументы.
	Name string `json:"name"`

	// Parameters Валидный JSON-объект с набором пар `ключ-значение`, которые описывают аргументы функции.
	Parameters map[string]interface{} `json:"parameters"`

	// ReturnParameters JSON-объект с описанием параметров, которые может вернуть ваша функция.
	ReturnParameters *map[string]interface{} `json:"return_parameters,omitempty"`
}

// CustomFunctions Массив с описанием пользовательских функций.
type CustomFunctions = []CustomFunction

// Embedding defines model for Embedding.
type Embedding struct {
	Data *[]struct {
		// Embedding Массив чисел, представляющий значения эмбеддинга для предоставленного текста.
		Embedding *[]float32 `json:"embedding,omitempty"`

		// Index Индекс, соответствующий индексу текста, полученного в массиве `input` запроса.
		Index *int `json:"index,omitempty"`

		// Object Тип объекта.
		Object *string `json:"object,omitempty"`
		Usage  *struct {
			// PromptTokens Количество токенов в строке, для которой сгенерирован эмбеддинг.
			PromptTokens *float32 `json:"prompt_tokens,omitempty"`
		} `json:"usage,omitempty"`
	} `json:"data,omitempty"`

	// Model Название модели, которая используется для вычисления эмбеддинга.
	Model *string `json:"model,omitempty"`

	// Object Формат структуры данных.
	Object *string `json:"object,omitempty"`
}

// EmbeddingsBody defines model for EmbeddingsBody.
type EmbeddingsBody struct {
	// Input Строка или массив строк, которые будут использованы для генерации эмбеддинга.
	Input EmbeddingsBody_Input `json:"input"`

	// Model Название модели, которая будет использована для создания эмбеддинга.
	//
	// Возможные значения:
	//
	// * `Embeddings` — базовая модель, доступная по умолчанию для векторного представления текстов;
	// * `EmbeddingsGigaR` — продвинутая модель с большим размером контекста.
	//
	// Запросы [тарифицируются](/ru/gigachat/api/tariffs) одинаково, независимо от использованной модели.
	//
	// Для улучшения результатов при работе с моделью EmbeddingsGigaR следуйте рекомендациям в разделе [Векторное представление текста](/ru/gigachat/guides/embeddings#embeddingsgigar-recommendations).
	Model string `json:"model"`
}

// EmbeddingsBodyInput0 defines model for .
type EmbeddingsBodyInput0 = string

// EmbeddingsBodyInput1 defines model for .
type EmbeddingsBodyInput1 = []string

// EmbeddingsBody_Input Строка или массив строк, которые будут использованы для генерации эмбеддинга.
type EmbeddingsBody_Input struct {
	union json.RawMessage
}

// File Описание файла, доступного в хранилище
type File struct {
	// AccessPolicy Доступность файла. Возможные значения:
	//
	// * `public`;
	// * `private`.
	AccessPolicy *FileAccessPolicy `json:"access_policy,omitempty"`

	// Bytes Размер файла в байтах.
	Bytes *int `json:"bytes,omitempty"`

	// CreatedAt Время создания файла в формате unix timestamp.
	CreatedAt *int `json:"created_at,omitempty"`

	// Filename Название файла.
	Filename *string `json:"filename,omitempty"`

	// Id Идентификатор файла, который можно использовать при [запросах на генерацию](/ru/gigachat/api/reference/rest/post-chat).
	// Для этого идентификаторы нужно передать в массиве `attachments`.
	//
	// Подробнее — в разделе [Обработка файлов](/ru/gigachat/guides/working-with-files).
	Id *string `json:"id,omitempty"`

	// Object Тип объекта.
	Object *string `json:"object,omitempty"`

	// Purpose Назначение файлов. Значение `general` указывает на то, что файлы могут использоваться для [генерации ответа модели](/ru/gigachat/guides/working-with-files)
	Purpose *FilePurpose `json:"purpose,omitempty"`
}

// FileAccessPolicy Доступность файла. Возможные значения:
//
// * `public`;
// * `private`.
type FileAccessPolicy string

// FilePurpose Назначение файлов. Значение `general` указывает на то, что файлы могут использоваться для [генерации ответа модели](/ru/gigachat/guides/working-with-files)
type FilePurpose string

// FileContent Содержимое файла в двоичном формате.
type FileContent = []byte

// FileDeleted defines model for FileDeleted.
type FileDeleted struct {
	// AccessPolicy Доступность файла.
	AccessPolicy *string `json:"access_policy,omitempty"`

	// Deleted Признак удаления файла.
	Deleted *bool `json:"deleted,omitempty"`

	// Id Идентификатор файла.
	Id *string `json:"id,omitempty"`
}

// FileUpload defines model for FileUpload.
type FileUpload struct {
	// File Загружаемый объект.
	File openapi_types.File `json:"file"`

	// Purpose Назначение загружаемого файла.
	Purpose *FileUploadPurpose `json:"purpose,omitempty"`
}

// FileUploadPurpose Назначение загружаемого файла.
type FileUploadPurpose string

// Files Массив объектов с данными доступных файлов.
type Files struct {
	Data *[]File `json:"data,omitempty"`
}

// FunctionValidationResult Объект с результатом валидации функции, описанной в формате JSON.
type FunctionValidationResult struct {
	// Errors Массив с описанием ошибок, возникших при валидации функции.
	// В отличие от предупреждений ошибки возникают, когда описание функции нарушает формат GigaChat API.
	// Например, если в описании отсутствуют обязательные блоки `name` или `parameters`.
	//
	// Если в описании функции есть ошибки (массив `errors`), то предупреждения (массив `warnings`) не передаются.
	//
	// Перед отправкой функции в запросе # START_RAW<APIMethod type="POST" path="/chat/completions" link="/ru/gigachat/api/reference/rest/post-chat"/># END_RAW ошибки нужно исправить.
	Errors *[]struct {
		// Description Описание ошибки.
		Description *string `json:"description,omitempty"`

		// SchemaLocation Указывает, где в схеме нужно внести изменения, чтобы исправить ошибку.
		SchemaLocation *string `json:"schema_location,omitempty"`
	} `json:"errors,omitempty"`

	// JsonAiRulesVersion Версия правил, которые используются для валидации функции.
	//
	// Передается, если запрос содержит описание функции в формате JSON.
	JsonAiRulesVersion *string `json:"json_ai_rules_version,omitempty"`

	// Message Сообщение о результате валидации функции.
	// Возможные значения:
	//
	// * `Function is valid` — описание функции полностью соответствует формату GigaChat API или содержит незначительные проблемы (блок `warnings`).
	// * `Incorrect function syntax` — описание функции не соответствует формату GigaChat API (ответ содержит блок `errors`).
	Message *FunctionValidationResultMessage `json:"message,omitempty"`

	// Status HTTP-код ответа.
	Status *int `json:"status,omitempty"`

	// Warnings Массив с описанием предупреждений, возникших при валидации функции.
	// В отличие от предупреждений ошибки возникают, когда описание функции нарушает формат GigaChat API.
	// Например, если в описании отсутствует необязательный массив образцов `few_shot_examples are missing`.
	//
	// Предупреждения (массив `warnings`) не передаются, если в описании функции есть ошибки (массив `errors`).
	Warnings *[]struct {
		// Description Описание предупреждения.
		Description *string `json:"description,omitempty"`

		// SchemaLocation Указывает, где в схеме нужно внести изменения, чтобы исправить предупреждения.
		SchemaLocation *string `json:"schema_location,omitempty"`
	} `json:"warnings,omitempty"`
}

// FunctionValidationResultMessage Сообщение о результате валидации функции.
// Возможные значения:
//
// * `Function is valid` — описание функции полностью соответствует формату GigaChat API или содержит незначительные проблемы (блок `warnings`).
// * `Incorrect function syntax` — описание функции не соответствует формату GigaChat API (ответ содержит блок `errors`).
type FunctionValidationResultMessage string

// MessagesRes Сгенерированное сообщение.
type MessagesRes struct {
	// Content Содержимое сообщения, например, результат генерации.
	// При передаче в [режиме потоковой генерации](/ru/gigachat/guides/response-token-streaming) передается частями. В предпосленем сообщении передаеся пустая строка `""`.
	//
	// В сообщениях с ролью `function_in_progress` содержит информацию о том, сколько времени осталось до завершения работы встроенной функции.
	Content *string `json:"content,omitempty"`

	// Created Передается в сообщениях с ролью`function_in_progress`. Содержит информацию о том, когда был создан фрагмент сообщения.
	Created      *int `json:"created,omitempty"`
	FunctionCall *struct {
		// Arguments Аргументы для вызова функции в виде пар ключ-значение.
		Arguments *map[string]interface{} `json:"arguments,omitempty"`

		// Name Название функции.
		Name *string `json:"name,omitempty"`
	} `json:"function_call,omitempty"`

	// FunctionsStateId Идентификатор, который объединяет массив функций, переданных в запросе.
	// Возвращается в ответе модели (сообщение с `"role": "assistant"`) при вызове встроенных или собственных функций.
	// Позволяет сохранить [контекст вызова функции](/ru/gigachat/guides/functions/calling-builtin-functions#sohranenie-konteksta) и повысить качество работы модели.
	// Для этого нужно передать идентификатор в запросе на генерацию в сообщении с ролью `assistant`.
	//
	// Сейчас поле работает только при обращении к [моделям в раннем доступе](/ru/gigachat/models/preview-models).
	FunctionsStateId *string `json:"functions_state_id,omitempty"`

	// Name Название вызванной [встроенной функции](/ru/gigachat/guides/functions/calling-builtin-functions).
	// Передается в сообщениях с ролью`function_in_progress`.
	// Возможные значения:
	//
	// * `text2image` - генерация изображения на основе описания;
	// * `text2model3d` — генерация 3D-модели на основе описания.
	Name *string `json:"name,omitempty"`

	// Role Роль автора сообщения.
	//
	// Роль `function_in_progress` используется при работе встроенных функций в режиме [потоковой передачи токенов](/ru/gigachat/guides/functions/calling-builtin-functions#potokovaya-peredacha-tokenov).
	Role *MessagesResRole `json:"role,omitempty"`
}

// MessagesResRole Роль автора сообщения.
//
// Роль `function_in_progress` используется при работе встроенных функций в режиме [потоковой передачи токенов](/ru/gigachat/guides/functions/calling-builtin-functions#potokovaya-peredacha-tokenov).
type MessagesResRole string

// Model defines model for Model.
type Model struct {
	// Id Название и версия модели, которая сгенерировала ответ. Описание доступных моделей смотрите в разделе [Модели GigaChat](/ru/gigachat/models).
	//
	// При обращении к моделям в раннем доступе к названию модели нужно добавлять постфикс `-preview`.
	// Например, `GigaChat-Pro-preview`.
	Id *string `json:"id,omitempty"`

	// Object Тип сущности в ответе, например, модель.
	Object *string `json:"object,omitempty"`

	// OwnedBy Владелец модели.
	OwnedBy *string `json:"owned_by,omitempty"`

	// Type Тип модели.
	// Возможные значения:
	//
	// * `chat` — модель для генерации;
	// * `aicheck` — модель для проверки, [создан ли текст с помощью ИИ](/ru/gigachat/api/reference/rest/post-ai-check);
	// * `embedder` — модель для создания [эмбеддингов](/ru/gigachat/api/reference/rest/post-embeddings).
	Type interface{} `json:"type,omitempty"`
}

// Models defines model for Models.
type Models struct {
	Data *[]Model `json:"data,omitempty"`

	// Object Тип сущности в ответе, например, список.
	Object *string `json:"object,omitempty"`
}

// Token defines model for Token.
type Token struct {
	// AccessToken Токен для авторизации запросов.
	AccessToken *string `json:"access_token,omitempty"`

	// ExpiresAt Дата и время истечения действия токена в миллисекундах, в формате unix timestamp.
	ExpiresAt *int `json:"expires_at,omitempty"`
}

// TokensCount defines model for TokensCount.
type TokensCount = []struct {
	// Characters Количество символов в соответствующей строке.
	Characters *int `json:"characters,omitempty"`

	// Object Описание того, какая информация содержится в объекте.
	Object *string `json:"object,omitempty"`

	// Tokens Количество токенов в соответствующей строке.
	Tokens *int `json:"tokens,omitempty"`
}

// TokensCountBody defines model for TokensCountBody.
type TokensCountBody struct {
	// Input Строка или массив строк, в которых надо подсчитать количество токенов.
	Input []string `json:"input"`

	// Model Название модели, которая будет использована для подсчета количества токенов.
	Model string `json:"model"`
}

// Usage Данные об использовании модели.
// При запуске [потоковой генерации](/ru/gigachat/guides/response-token-streaming), объект приходит в предпоследнем событии.
type Usage struct {
	// CompletionTokens Количество токенов, сгенерированных моделью (роль `assistant`).
	CompletionTokens *int32 `json:"completion_tokens,omitempty"`

	// PrecachedPromptTokens Количество ранее закэшированных токенов, которые были использованы при обработке запроса.
	// Кэшированные токены вычитаются из общего числа оплачиваемых токенов (поле `total_tokens`).
	//
	// Модели GigaChat в течение некоторого времени сохраняют контекст запроса (историю сообщений массива `messages`, описание функций) с помощью кэширования токенов. Это позволяет повысить скорость ответа моделей и снизить стоимость работы с GigaChat API.
	//
	// # START_RAW
	// <Admonition type="tip">
	// # END_RAW
	//
	// Для повышения вероятности использования сохраненных токенов используйте [кэширование запросов](/ru/gigachat/guides/keeping-context#keshirovanie-zaprosov).
	//
	// # START_RAW
	// </Admonition>
	// # END_RAW
	//
	// [Подробнее о подсчете токенов](/ru/gigachat/guides/counting-tokens).
	PrecachedPromptTokens *int32 `json:"precached_prompt_tokens,omitempty"`

	// PromptTokens Количество токенов во входящем сообщении (роль `user`).
	PromptTokens *int32 `json:"prompt_tokens,omitempty"`

	// TotalTokens Общее число токенов, подлежащих тарификации, после вычитания кэшированных токенов (поле `precached_prompt_tokens`).
	TotalTokens *int32 `json:"total_tokens,omitempty"`
}

// AiCheck defines model for aiCheck.
type AiCheck struct {
	// Input Текст, который будет проверен на наличие содержимого, сгенерированного с помощью нейросетевых моделей.
	// Проверка доступна только для текстов на русском языке.
	// Минимальная длина текста — 20 слов.
	Input string `json:"input"`

	// Model Название модели.
	// Модель GigaCheckClassification лучше всего подходит для анализа и разделения текста на два класса: написанный человеком или сгенерированный нейросетью (`ai`/`human`). В модели GigaCheckDetection добавляется третий класс — `mixed` (`ai`+`human`), что позволяет определять тексты, частично созданные с помощью ИИ.
	Model AiCheckModel `json:"model"`
}

// AiCheckModel Название модели.
// Модель GigaCheckClassification лучше всего подходит для анализа и разделения текста на два класса: написанный человеком или сгенерированный нейросетью (`ai`/`human`). В модели GigaCheckDetection добавляется третий класс — `mixed` (`ai`+`human`), что позволяет определять тексты, частично созданные с помощью ИИ.
type AiCheckModel string

// AiCheckResponse defines model for aiCheckResponse.
type AiCheckResponse struct {
	// AiIntervals Части текста, сгенерированные моделью.
	// Обозначаются индексами символов, с которых начинаются и заканчиваются сгенерированные фрагменты.
	//
	// Содержит пустой массив если текст полностью сгенерирован с помощью нейросетевых моделей (`"category": "ai"`) или написан человеком (`"category": "human"`).
	AiIntervals *[][]int `json:"ai_intervals,omitempty"`

	// Category Результат проверки текста. Возможные значения:
	//
	// * `ai` — текст сгенерирован с помощью нейросетевых моделей;
	// * `human` — текст написан человеком;
	// * `mixed` — текст содержит как фрагменты сгенерированные с помощью моделей, так и написанные человеком.
	Category *AiCheckResponseCategory `json:"category,omitempty"`

	// Characters Количество символов в переданном тексте.
	Characters *int `json:"characters,omitempty"`

	// Tokens Количество токенов в переданном тексте.
	Tokens *int `json:"tokens,omitempty"`
}

// AiCheckResponseCategory Результат проверки текста. Возможные значения:
//
// * `ai` — текст сгенерирован с помощью нейросетевых моделей;
// * `human` — текст написан человеком;
// * `mixed` — текст содержит как фрагменты сгенерированные с помощью моделей, так и написанные человеком.
type AiCheckResponseCategory string

// FunctionCallName defines model for function_call_name.
type FunctionCallName struct {
	// Name Название функции.
	//
	// В поле можно передать как название собственной функции, описание которой содержится в массиве `functions`, так и название одной из [встроенных функций](/ru/gigachat/guides/functions/calling-builtin-functions).
	Name *string `json:"name,omitempty"`
}

// FunctionCallNoneAuto Режим работы с функциями:
//
// * `auto` — в авторежиме модель, основываясь на тексте сообщений, решает нужно ли использовать одну из [встроенных функций](/ru/gigachat/guides/functions/calling-builtin-functions) или сгенерировать аргументы для пользовательских функций, описанных в массиве `functions`. При этом, если массив содержит описание хотя бы одной пользовательской функции, модель сможет вызвать встроенную функцию, только если ее название передано в массиве `functions`;
//
// * `none` — модель не будет вызывать встроенные функции или генерировать аргументы для пользовательских функций, а просто сгенерирует ответ в соответствии с полученными сообщениями.
type FunctionCallNoneAuto string

// Message defines model for message.
type Message struct {
	// Attachments Массив идентификаторов файлов, которые нужно использовать при генерации.
	// Идентификатор присваивается файлу при [загрузке в хранилище](/ru/gigachat/api/reference/rest/post-file).
	// Посмотреть список файлов в хранилище можно с помощью метода # START_RAW<APIMethod type="GET" path="/files" link="/ru/gigachat/api/reference/rest/get-files"/># END_RAW.
	//
	// При работе с текстовыми документами в одном запросе на генерацию нужно передавать только один идентификатор.
	// Если вы передадите несколько идентификаторов файлов, для генерации будет использован только первый файл из списка.
	// При использовании больших текстовых файлов в запросах на генерацию, их содержимое может превышать [размер контекста модели](/ru/gigachat/models#modeli-dlya-generatsii).
	// В таком случае вернется [ошибка с кодом 422](/ru/gigachat/api/errors-description?responseCode=422).
	//
	// В одном сообщении (объект в массиве `messages`) можно передать только одно изображение.
	// В одной сессии можно передать до 10 изображений.
	//
	// # START_RAW
	// <Admonition type="note">
	// # END_RAW
	//
	// При этом общий размер запроса при работе с изображениями и аудио должен быть меньше 80 Мб.
	//
	// Например, ваш запрос может включать текст промпта и идентификаторы изображения размером 12 Мб, и двух аудиофайлов размером 33 Мб и 21 Мб. Что в сумме даст запрос размером больше 66 Мб, в зависимости от размера промпта.
	//
	// Размер текстовых документов не влияет на размер запроса, но их содержимое может превышать контекстное окно модели.
	//
	// # START_RAW
	// </Admonition>
	// # END_RAW
	//
	// Подробнее — в разделе [Обработка файлов](/ru/gigachat/guides/working-with-files)
	Attachments *[]string `json:"attachments,omitempty"`

	// Content Содержимое сообщения. Зависит от роли.
	//
	// Если поле передается в сообщении с ролью `function`, то в нем указывается обернутый в строку валидный JSON-объект с аргументами функции, указанной в поле `function_call.name`.
	//
	// В остальных случаях содержит либо системный промпт (сообщение с ролью `system`), либо текст сообщения пользователя или модели.
	//
	// Передавайте текст в кодировке UTF8.
	// Это позволит снизить расход токенов при обработке сообщения.
	Content *string `json:"content,omitempty"`

	// FunctionsStateId Идентификатор, который объединяет массив функций, переданных в запросе.
	// Возвращается в ответе модели (сообщение с `"role": "assistant"`) при вызове встроенных или собственных функций.
	// Позволяет сохранить [контекст вызова функции](/ru/gigachat/guides/functions/calling-builtin-functions#sohranenie-konteksta) и повысить качество работы модели.
	// Для этого нужно передать идентификатор в запросе на генерацию в сообщении с ролью `assistant`.
	//
	// Сейчас поле работает только при обращении к [моделям в раннем доступе](/ru/gigachat/models/preview-models).
	FunctionsStateId *string `json:"functions_state_id,omitempty"`

	// Role Роль автора сообщения:
	//
	// * `system` — системный промпт, который задает роль модели, например, должна модель отвечать как академик или как школьник;
	// * `assistant` — ответ модели;
	// * `user` — сообщение пользователя;
	// * `function` — сообщение с результатом работы [пользовательской функции](/ru/gigachat/guides/functions/generating-arguments-for-custom-functions). В сообщении с этой ролью передавайте результаты работы функции в поле `content` в форме валидного JSON-объекта, обернутого в строку.
	//
	// Для сохранения контекста диалога с пользователем передайте несколько сообщений. Подробнее читайте в разделе [Работа с историей чата](/ru/gigachat/guides/keeping-context).
	Role *MessageRole `json:"role,omitempty"`
}

// MessageRole Роль автора сообщения:
//
// * `system` — системный промпт, который задает роль модели, например, должна модель отвечать как академик или как школьник;
// * `assistant` — ответ модели;
// * `user` — сообщение пользователя;
// * `function` — сообщение с результатом работы [пользовательской функции](/ru/gigachat/guides/functions/generating-arguments-for-custom-functions). В сообщении с этой ролью передавайте результаты работы функции в поле `content` в форме валидного JSON-объекта, обернутого в строку.
//
// Для сохранения контекста диалога с пользователем передайте несколько сообщений. Подробнее читайте в разделе [Работа с историей чата](/ru/gigachat/guides/keeping-context).
type MessageRole string

// XClientId defines model for xClientId.
type XClientId = string

// XRequestId defines model for xRequestId.
type XRequestId = string

// XSessionId defines model for xSessionId.
type XSessionId = string

// AuthUnauthorizedError defines model for AuthUnauthorizedError.
type AuthUnauthorizedError struct {
	// Code Код ошибки.
	Code *int `json:"code,omitempty"`

	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`
}

// BatchTaskNotFound defines model for BatchTaskNotFound.
type BatchTaskNotFound struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// InternalError defines model for InternalError.
type InternalError struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// NoSuchModel defines model for NoSuchModel.
type NoSuchModel struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// PermissionDeniedError defines model for PermissionDeniedError.
type PermissionDeniedError struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	// Message Описание ошибки.
	Message *string `json:"message,omitempty"`

	// Status HTTP-код сообщения.
	Status *int `json:"status,omitempty"`
}

// PostAiCheckParams defines parameters for PostAiCheck.
type PostAiCheckParams struct {
	// XClientID Произвольный идентификатор пользователя, который используется для логирования.
	//
	// Если вы передали этот заголовок при запросе на создание изображения, то для скачивания изображения в запросе # START_RAW<APIMethod type="GET" path="/files/{file_id}/content" link="/ru/gigachat/api/reference/rest/get-file-id"/># END_RAW нужно передать этот же заголовок.
	XClientID *XClientId `json:"X-Client-ID,omitempty"`

	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`
}

// GetBalanceParams defines parameters for GetBalance.
type GetBalanceParams struct {
	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`
}

// GetBatchesParams defines parameters for GetBatches.
type GetBatchesParams struct {
	// BatchId Идентификатор ранее загруженной пакетной задачи.
	BatchId *string `form:"batch_id,omitempty" json:"batch_id,omitempty"`

	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`

	// XClientID Произвольный идентификатор пользователя, который используется для логирования.
	//
	// Если вы передали этот заголовок при запросе на создание изображения, то для скачивания изображения в запросе # START_RAW<APIMethod type="GET" path="/files/{file_id}/content" link="/ru/gigachat/api/reference/rest/get-file-id"/># END_RAW нужно передать этот же заголовок.
	XClientID   *XClientId `json:"X-Client-ID,omitempty"`
	ContentType string     `json:"Content-Type"`
}

// PostBatchesParams defines parameters for PostBatches.
type PostBatchesParams struct {
	Method *PostBatchesParamsMethod `form:"method,omitempty" json:"method,omitempty"`

	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`
}

// PostBatchesParamsMethod defines parameters for PostBatches.
type PostBatchesParamsMethod string

// PostChatParams defines parameters for PostChat.
type PostChatParams struct {
	// XClientID Произвольный идентификатор пользователя, который используется для логирования.
	//
	// Если вы передали этот заголовок при запросе на создание изображения, то для скачивания изображения в запросе # START_RAW<APIMethod type="GET" path="/files/{file_id}/content" link="/ru/gigachat/api/reference/rest/get-file-id"/># END_RAW нужно передать этот же заголовок.
	XClientID *XClientId `json:"X-Client-ID,omitempty"`

	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`
}

// GetFileIdParams defines parameters for GetFileId.
type GetFileIdParams struct {
	XClientID *string `json:"X-Client-ID,omitempty"`
}

// FunctionValidationParams defines parameters for FunctionValidation.
type FunctionValidationParams struct {
	// XRequestID Произвольный идентификатор запроса, который используется для логирования.
	XRequestID *XRequestId `json:"X-Request-ID,omitempty"`

	// XSessionID Произвольный идентификатор сессии, который используется для логирования.
	XSessionID *XSessionId `json:"X-Session-ID,omitempty"`
}

// PostTokenFormdataBody defines parameters for PostToken.
type PostTokenFormdataBody struct {
	// Scope Версия API. Возможные значения:
	//
	//   * `GIGACHAT_API_PERS` — доступ для физических лиц.
	//   * `GIGACHAT_API_B2B` — доступ для ИП и юридических лиц по [платным пакетам](/ru/gigachat/quickstart/legal-tokens-purchase#pokupka-paketov).
	//   * `GIGACHAT_API_CORP` — доступ для ИП и юридических лиц по схеме [pay-as-you-go](/ru/gigachat/quickstart/legal-tokens-purchase#oplata-pay-as-you-go).
	Scope PostTokenFormdataBodyScope `form:"scope" json:"scope"`
}

// PostTokenParams defines parameters for PostToken.
type PostTokenParams struct {
	// RqUID Уникальный идентификатор запроса. Соответствует формату [`uuid4`](https://www.uuidgenerator.net/version4).
	//
	// Параметр для журналирования входящих вызовов и разбора инцидентов.
	// Идентификатор нужно указать самостоятельно, для этого можно использовать стандартные библиотеки и классы для генерации UUID и GUID.
	//
	// Пример: `6f0b1291-c7f3-43c6-bb2e-9f3efb2dc98e`.
	RqUID string `json:"RqUID"`
}

// PostTokenFormdataBodyScope defines parameters for PostToken.
type PostTokenFormdataBodyScope string

// PostAiCheckJSONRequestBody defines body for PostAiCheck for application/json ContentType.
type PostAiCheckJSONRequestBody = AiCheck

// PostChatJSONRequestBody defines body for PostChat for application/json ContentType.
type PostChatJSONRequestBody = Chat

// PostEmbeddingsJSONRequestBody defines body for PostEmbeddings for application/json ContentType.
type PostEmbeddingsJSONRequestBody = EmbeddingsBody

// PostFileMultipartRequestBody defines body for PostFile for multipart/form-data ContentType.
type PostFileMultipartRequestBody = FileUpload

// FunctionValidationJSONRequestBody defines body for FunctionValidation for application/json ContentType.
type FunctionValidationJSONRequestBody = CustomFunction

// PostTokenFormdataRequestBody defines body for PostToken for application/x-www-form-urlencoded ContentType.
type PostTokenFormdataRequestBody PostTokenFormdataBody

// PostTokensCountJSONRequestBody defines body for PostTokensCount for application/json ContentType.
type PostTokensCountJSONRequestBody = TokensCountBody

// AsFunctionCallName returns the union data inside the Chat_FunctionCall as a FunctionCallName
func (t Chat_FunctionCall) AsFunctionCallName() (FunctionCallName, error) {
	var body FunctionCallName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionCallName overwrites any union data inside the Chat_FunctionCall as the provided FunctionCallName
func (t *Chat_FunctionCall) FromFunctionCallName(v FunctionCallName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionCallName performs a merge with any union data inside the Chat_FunctionCall, using the provided FunctionCallName
func (t *Chat_FunctionCall) MergeFunctionCallName(v FunctionCallName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFunctionCallNoneAuto returns the union data inside the Chat_FunctionCall as a FunctionCallNoneAuto
func (t Chat_FunctionCall) AsFunctionCallNoneAuto() (FunctionCallNoneAuto, error) {
	var body FunctionCallNoneAuto
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFunctionCallNoneAuto overwrites any union data inside the Chat_FunctionCall as the provided FunctionCallNoneAuto
func (t *Chat_FunctionCall) FromFunctionCallNoneAuto(v FunctionCallNoneAuto) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFunctionCallNoneAuto performs a merge with any union data inside the Chat_FunctionCall, using the provided FunctionCallNoneAuto
func (t *Chat_FunctionCall) MergeFunctionCallNoneAuto(v FunctionCallNoneAuto) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Chat_FunctionCall) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Chat_FunctionCall) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEmbeddingsBodyInput0 returns the union data inside the EmbeddingsBody_Input as a EmbeddingsBodyInput0
func (t EmbeddingsBody_Input) AsEmbeddingsBodyInput0() (EmbeddingsBodyInput0, error) {
	var body EmbeddingsBodyInput0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbeddingsBodyInput0 overwrites any union data inside the EmbeddingsBody_Input as the provided EmbeddingsBodyInput0
func (t *EmbeddingsBody_Input) FromEmbeddingsBodyInput0(v EmbeddingsBodyInput0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbeddingsBodyInput0 performs a merge with any union data inside the EmbeddingsBody_Input, using the provided EmbeddingsBodyInput0
func (t *EmbeddingsBody_Input) MergeEmbeddingsBodyInput0(v EmbeddingsBodyInput0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmbeddingsBodyInput1 returns the union data inside the EmbeddingsBody_Input as a EmbeddingsBodyInput1
func (t EmbeddingsBody_Input) AsEmbeddingsBodyInput1() (EmbeddingsBodyInput1, error) {
	var body EmbeddingsBodyInput1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmbeddingsBodyInput1 overwrites any union data inside the EmbeddingsBody_Input as the provided EmbeddingsBodyInput1
func (t *EmbeddingsBody_Input) FromEmbeddingsBodyInput1(v EmbeddingsBodyInput1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmbeddingsBodyInput1 performs a merge with any union data inside the EmbeddingsBody_Input, using the provided EmbeddingsBodyInput1
func (t *EmbeddingsBody_Input) MergeEmbeddingsBodyInput1(v EmbeddingsBodyInput1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EmbeddingsBody_Input) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EmbeddingsBody_Input) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostAiCheckWithBody request with any body
	PostAiCheckWithBody(ctx context.Context, params *PostAiCheckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAiCheck(ctx context.Context, params *PostAiCheckParams, body PostAiCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalance request
	GetBalance(ctx context.Context, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatches request
	GetBatches(ctx context.Context, params *GetBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBatchesWithBody request with any body
	PostBatchesWithBody(ctx context.Context, params *PostBatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostChatWithBody request with any body
	PostChatWithBody(ctx context.Context, params *PostChatParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostChat(ctx context.Context, params *PostChatParams, body PostChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEmbeddingsWithBody request with any body
	PostEmbeddingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEmbeddings(ctx context.Context, body PostEmbeddingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFiles request
	GetFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFileWithBody request with any body
	PostFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFileId request
	GetFileId(ctx context.Context, fileId string, params *GetFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFile request
	GetFile(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FileDelete request
	FileDelete(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FunctionValidationWithBody request with any body
	FunctionValidationWithBody(ctx context.Context, params *FunctionValidationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FunctionValidation(ctx context.Context, params *FunctionValidationParams, body FunctionValidationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModels request
	GetModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTokenWithBody request with any body
	PostTokenWithBody(ctx context.Context, params *PostTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTokenWithFormdataBody(ctx context.Context, params *PostTokenParams, body PostTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTokensCountWithBody request with any body
	PostTokensCountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTokensCount(ctx context.Context, body PostTokensCountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostAiCheckWithBody(ctx context.Context, params *PostAiCheckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAiCheckRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAiCheck(ctx context.Context, params *PostAiCheckParams, body PostAiCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAiCheckRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalance(ctx context.Context, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatches(ctx context.Context, params *GetBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBatchesWithBody(ctx context.Context, params *PostBatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBatchesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostChatWithBody(ctx context.Context, params *PostChatParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostChatRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostChat(ctx context.Context, params *PostChatParams, body PostChatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostChatRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEmbeddingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEmbeddingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEmbeddings(ctx context.Context, body PostEmbeddingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEmbeddingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFileId(ctx context.Context, fileId string, params *GetFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileIdRequest(c.Server, fileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFile(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFileRequest(c.Server, file)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FileDelete(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFileDeleteRequest(c.Server, file)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionValidationWithBody(ctx context.Context, params *FunctionValidationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionValidationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FunctionValidation(ctx context.Context, params *FunctionValidationParams, body FunctionValidationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFunctionValidationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTokenWithBody(ctx context.Context, params *PostTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokenRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTokenWithFormdataBody(ctx context.Context, params *PostTokenParams, body PostTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokenRequestWithFormdataBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTokensCountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokensCountRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTokensCount(ctx context.Context, body PostTokensCountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTokensCountRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostAiCheckRequest calls the generic PostAiCheck builder with application/json body
func NewPostAiCheckRequest(server string, params *PostAiCheckParams, body PostAiCheckJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAiCheckRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAiCheckRequestWithBody generates requests for PostAiCheck with any type of body
func NewPostAiCheckRequestWithBody(server string, params *PostAiCheckParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ai/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XClientID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-ID", runtime.ParamLocationHeader, *params.XClientID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Client-ID", headerParam0)
		}

		if params.XRequestID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam1)
		}

		if params.XSessionID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam2)
		}

	}

	return req, nil
}

// NewGetBalanceRequest generates requests for GetBalance
func NewGetBalanceRequest(server string, params *GetBalanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/balance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

		if params.XSessionID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam1)
		}

	}

	return req, nil
}

// NewGetBatchesRequest generates requests for GetBatches
func NewGetBatchesRequest(server string, params *GetBatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BatchId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batch_id", runtime.ParamLocationQuery, *params.BatchId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

		if params.XSessionID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam1)
		}

		if params.XClientID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Client-ID", runtime.ParamLocationHeader, *params.XClientID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Client-ID", headerParam2)
		}

		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam3)

	}

	return req, nil
}

// NewPostBatchesRequestWithBody generates requests for PostBatches with any type of body
func NewPostBatchesRequestWithBody(server string, params *PostBatchesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Method != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "method", runtime.ParamLocationQuery, *params.Method); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

		if params.XSessionID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam1)
		}

	}

	return req, nil
}

// NewPostChatRequest calls the generic PostChat builder with application/json body
func NewPostChatRequest(server string, params *PostChatParams, body PostChatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostChatRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostChatRequestWithBody generates requests for PostChat with any type of body
func NewPostChatRequestWithBody(server string, params *PostChatParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/completions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XClientID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-ID", runtime.ParamLocationHeader, *params.XClientID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Client-ID", headerParam0)
		}

		if params.XRequestID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam1)
		}

		if params.XSessionID != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam2)
		}

	}

	return req, nil
}

// NewPostEmbeddingsRequest calls the generic PostEmbeddings builder with application/json body
func NewPostEmbeddingsRequest(server string, body PostEmbeddingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEmbeddingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEmbeddingsRequestWithBody generates requests for PostEmbeddings with any type of body
func NewPostEmbeddingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/embeddings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFilesRequest generates requests for GetFiles
func NewGetFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFileRequestWithBody generates requests for PostFile with any type of body
func NewPostFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFileIdRequest generates requests for GetFileId
func NewGetFileIdRequest(server string, fileId string, params *GetFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file_id", runtime.ParamLocationPath, fileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XClientID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Client-ID", runtime.ParamLocationHeader, *params.XClientID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Client-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetFileRequest generates requests for GetFile
func NewGetFileRequest(server string, file string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file", runtime.ParamLocationPath, file)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFileDeleteRequest generates requests for FileDelete
func NewFileDeleteRequest(server string, file string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "file", runtime.ParamLocationPath, file)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFunctionValidationRequest calls the generic FunctionValidation builder with application/json body
func NewFunctionValidationRequest(server string, params *FunctionValidationParams, body FunctionValidationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFunctionValidationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFunctionValidationRequestWithBody generates requests for FunctionValidation with any type of body
func NewFunctionValidationRequestWithBody(server string, params *FunctionValidationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/functions/validate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRequestID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Request-ID", runtime.ParamLocationHeader, *params.XRequestID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Request-ID", headerParam0)
		}

		if params.XSessionID != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "X-Session-ID", runtime.ParamLocationHeader, *params.XSessionID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Session-ID", headerParam1)
		}

	}

	return req, nil
}

// NewGetModelsRequest generates requests for GetModels
func NewGetModelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/models")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTokenRequestWithFormdataBody calls the generic PostToken builder with application/x-www-form-urlencoded body
func NewPostTokenRequestWithFormdataBody(server string, params *PostTokenParams, body PostTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostTokenRequestWithBody(server, params, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostTokenRequestWithBody generates requests for PostToken with any type of body
func NewPostTokenRequestWithBody(server string, params *PostTokenParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "RqUID", runtime.ParamLocationHeader, params.RqUID)
		if err != nil {
			return nil, err
		}

		req.Header.Set("RqUID", headerParam0)

	}

	return req, nil
}

// NewPostTokensCountRequest calls the generic PostTokensCount builder with application/json body
func NewPostTokensCountRequest(server string, body PostTokensCountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTokensCountRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTokensCountRequestWithBody generates requests for PostTokensCount with any type of body
func NewPostTokensCountRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokens/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostAiCheckWithBodyWithResponse request with any body
	PostAiCheckWithBodyWithResponse(ctx context.Context, params *PostAiCheckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAiCheckResponse, error)

	PostAiCheckWithResponse(ctx context.Context, params *PostAiCheckParams, body PostAiCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAiCheckResponse, error)

	// GetBalanceWithResponse request
	GetBalanceWithResponse(ctx context.Context, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error)

	// GetBatchesWithResponse request
	GetBatchesWithResponse(ctx context.Context, params *GetBatchesParams, reqEditors ...RequestEditorFn) (*GetBatchesResponse, error)

	// PostBatchesWithBodyWithResponse request with any body
	PostBatchesWithBodyWithResponse(ctx context.Context, params *PostBatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBatchesResponse, error)

	// PostChatWithBodyWithResponse request with any body
	PostChatWithBodyWithResponse(ctx context.Context, params *PostChatParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostChatResponse, error)

	PostChatWithResponse(ctx context.Context, params *PostChatParams, body PostChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostChatResponse, error)

	// PostEmbeddingsWithBodyWithResponse request with any body
	PostEmbeddingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEmbeddingsResponse, error)

	PostEmbeddingsWithResponse(ctx context.Context, body PostEmbeddingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEmbeddingsResponse, error)

	// GetFilesWithResponse request
	GetFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilesResponse, error)

	// PostFileWithBodyWithResponse request with any body
	PostFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFileResponse, error)

	// GetFileIdWithResponse request
	GetFileIdWithResponse(ctx context.Context, fileId string, params *GetFileIdParams, reqEditors ...RequestEditorFn) (*GetFileIdResponse, error)

	// GetFileWithResponse request
	GetFileWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*GetFileResponse, error)

	// FileDeleteWithResponse request
	FileDeleteWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*FileDeleteResponse, error)

	// FunctionValidationWithBodyWithResponse request with any body
	FunctionValidationWithBodyWithResponse(ctx context.Context, params *FunctionValidationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionValidationResponse, error)

	FunctionValidationWithResponse(ctx context.Context, params *FunctionValidationParams, body FunctionValidationJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionValidationResponse, error)

	// GetModelsWithResponse request
	GetModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetModelsResponse, error)

	// PostTokenWithBodyWithResponse request with any body
	PostTokenWithBodyWithResponse(ctx context.Context, params *PostTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokenResponse, error)

	PostTokenWithFormdataBodyWithResponse(ctx context.Context, params *PostTokenParams, body PostTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostTokenResponse, error)

	// PostTokensCountWithBodyWithResponse request with any body
	PostTokensCountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokensCountResponse, error)

	PostTokensCountWithResponse(ctx context.Context, body PostTokensCountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTokensCountResponse, error)
}

type PostAiCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AiCheckResponse
}

// Status returns HTTPResponse.Status
func (r PostAiCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAiCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Balance
	JSON401      *UnauthorizedError
	JSON403      *PermissionDeniedError
}

// Status returns HTTPResponse.Status
func (r GetBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesList
	JSON401      *UnauthorizedError
	JSON404      *BatchTaskNotFound
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r GetBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchResponse
	JSON401      *UnauthorizedError
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PostBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostChatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatCompletion
	JSON401      *UnauthorizedError
	JSON404      *NoSuchModel
	JSON422      *ValidationError
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r PostChatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostChatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEmbeddingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Embedding
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostEmbeddingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEmbeddingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Files
}

// Status returns HTTPResponse.Status
func (r GetFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *File
}

// Status returns HTTPResponse.Status
func (r PostFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON404      *NoSuchModel
}

// Status returns HTTPResponse.Status
func (r GetFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *File
}

// Status returns HTTPResponse.Status
func (r GetFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FileDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileDeleted
}

// Status returns HTTPResponse.Status
func (r FileDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FileDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FunctionValidationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FunctionValidationResult
	JSON401      *UnauthorizedError
	JSON429      *TooManyRequests
	JSON500      *InternalError
}

// Status returns HTTPResponse.Status
func (r FunctionValidationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FunctionValidationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Models
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GetModelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Token
	JSON401      *AuthUnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTokensCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokensCount
	JSON401      *UnauthorizedError
}

// Status returns HTTPResponse.Status
func (r PostTokensCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTokensCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostAiCheckWithBodyWithResponse request with arbitrary body returning *PostAiCheckResponse
func (c *ClientWithResponses) PostAiCheckWithBodyWithResponse(ctx context.Context, params *PostAiCheckParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAiCheckResponse, error) {
	rsp, err := c.PostAiCheckWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAiCheckResponse(rsp)
}

func (c *ClientWithResponses) PostAiCheckWithResponse(ctx context.Context, params *PostAiCheckParams, body PostAiCheckJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAiCheckResponse, error) {
	rsp, err := c.PostAiCheck(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAiCheckResponse(rsp)
}

// GetBalanceWithResponse request returning *GetBalanceResponse
func (c *ClientWithResponses) GetBalanceWithResponse(ctx context.Context, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error) {
	rsp, err := c.GetBalance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceResponse(rsp)
}

// GetBatchesWithResponse request returning *GetBatchesResponse
func (c *ClientWithResponses) GetBatchesWithResponse(ctx context.Context, params *GetBatchesParams, reqEditors ...RequestEditorFn) (*GetBatchesResponse, error) {
	rsp, err := c.GetBatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchesResponse(rsp)
}

// PostBatchesWithBodyWithResponse request with arbitrary body returning *PostBatchesResponse
func (c *ClientWithResponses) PostBatchesWithBodyWithResponse(ctx context.Context, params *PostBatchesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBatchesResponse, error) {
	rsp, err := c.PostBatchesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBatchesResponse(rsp)
}

// PostChatWithBodyWithResponse request with arbitrary body returning *PostChatResponse
func (c *ClientWithResponses) PostChatWithBodyWithResponse(ctx context.Context, params *PostChatParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostChatResponse, error) {
	rsp, err := c.PostChatWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostChatResponse(rsp)
}

func (c *ClientWithResponses) PostChatWithResponse(ctx context.Context, params *PostChatParams, body PostChatJSONRequestBody, reqEditors ...RequestEditorFn) (*PostChatResponse, error) {
	rsp, err := c.PostChat(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostChatResponse(rsp)
}

// PostEmbeddingsWithBodyWithResponse request with arbitrary body returning *PostEmbeddingsResponse
func (c *ClientWithResponses) PostEmbeddingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEmbeddingsResponse, error) {
	rsp, err := c.PostEmbeddingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEmbeddingsResponse(rsp)
}

func (c *ClientWithResponses) PostEmbeddingsWithResponse(ctx context.Context, body PostEmbeddingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEmbeddingsResponse, error) {
	rsp, err := c.PostEmbeddings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEmbeddingsResponse(rsp)
}

// GetFilesWithResponse request returning *GetFilesResponse
func (c *ClientWithResponses) GetFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFilesResponse, error) {
	rsp, err := c.GetFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilesResponse(rsp)
}

// PostFileWithBodyWithResponse request with arbitrary body returning *PostFileResponse
func (c *ClientWithResponses) PostFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFileResponse, error) {
	rsp, err := c.PostFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFileResponse(rsp)
}

// GetFileIdWithResponse request returning *GetFileIdResponse
func (c *ClientWithResponses) GetFileIdWithResponse(ctx context.Context, fileId string, params *GetFileIdParams, reqEditors ...RequestEditorFn) (*GetFileIdResponse, error) {
	rsp, err := c.GetFileId(ctx, fileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileIdResponse(rsp)
}

// GetFileWithResponse request returning *GetFileResponse
func (c *ClientWithResponses) GetFileWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*GetFileResponse, error) {
	rsp, err := c.GetFile(ctx, file, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFileResponse(rsp)
}

// FileDeleteWithResponse request returning *FileDeleteResponse
func (c *ClientWithResponses) FileDeleteWithResponse(ctx context.Context, file string, reqEditors ...RequestEditorFn) (*FileDeleteResponse, error) {
	rsp, err := c.FileDelete(ctx, file, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFileDeleteResponse(rsp)
}

// FunctionValidationWithBodyWithResponse request with arbitrary body returning *FunctionValidationResponse
func (c *ClientWithResponses) FunctionValidationWithBodyWithResponse(ctx context.Context, params *FunctionValidationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FunctionValidationResponse, error) {
	rsp, err := c.FunctionValidationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionValidationResponse(rsp)
}

func (c *ClientWithResponses) FunctionValidationWithResponse(ctx context.Context, params *FunctionValidationParams, body FunctionValidationJSONRequestBody, reqEditors ...RequestEditorFn) (*FunctionValidationResponse, error) {
	rsp, err := c.FunctionValidation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFunctionValidationResponse(rsp)
}

// GetModelsWithResponse request returning *GetModelsResponse
func (c *ClientWithResponses) GetModelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetModelsResponse, error) {
	rsp, err := c.GetModels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetModelsResponse(rsp)
}

// PostTokenWithBodyWithResponse request with arbitrary body returning *PostTokenResponse
func (c *ClientWithResponses) PostTokenWithBodyWithResponse(ctx context.Context, params *PostTokenParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokenResponse, error) {
	rsp, err := c.PostTokenWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokenResponse(rsp)
}

func (c *ClientWithResponses) PostTokenWithFormdataBodyWithResponse(ctx context.Context, params *PostTokenParams, body PostTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostTokenResponse, error) {
	rsp, err := c.PostTokenWithFormdataBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokenResponse(rsp)
}

// PostTokensCountWithBodyWithResponse request with arbitrary body returning *PostTokensCountResponse
func (c *ClientWithResponses) PostTokensCountWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTokensCountResponse, error) {
	rsp, err := c.PostTokensCountWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokensCountResponse(rsp)
}

func (c *ClientWithResponses) PostTokensCountWithResponse(ctx context.Context, body PostTokensCountJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTokensCountResponse, error) {
	rsp, err := c.PostTokensCount(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTokensCountResponse(rsp)
}

// ParsePostAiCheckResponse parses an HTTP response from a PostAiCheckWithResponse call
func ParsePostAiCheckResponse(rsp *http.Response) (*PostAiCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAiCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AiCheckResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBalanceResponse parses an HTTP response from a GetBalanceWithResponse call
func ParseGetBalanceResponse(rsp *http.Response) (*GetBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Balance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest PermissionDeniedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetBatchesResponse parses an HTTP response from a GetBatchesWithResponse call
func ParseGetBatchesResponse(rsp *http.Response) (*GetBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BatchTaskNotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostBatchesResponse parses an HTTP response from a PostBatchesWithResponse call
func ParsePostBatchesResponse(rsp *http.Response) (*PostBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostChatResponse parses an HTTP response from a PostChatWithResponse call
func ParsePostChatResponse(rsp *http.Response) (*PostChatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostChatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatCompletion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NoSuchModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 200:
		// Content-type (text/event-stream) unsupported

	}

	return response, nil
}

// ParsePostEmbeddingsResponse parses an HTTP response from a PostEmbeddingsWithResponse call
func ParsePostEmbeddingsResponse(rsp *http.Response) (*PostEmbeddingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEmbeddingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Embedding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFilesResponse parses an HTTP response from a GetFilesWithResponse call
func ParseGetFilesResponse(rsp *http.Response) (*GetFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Files
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFileResponse parses an HTTP response from a PostFileWithResponse call
func ParsePostFileResponse(rsp *http.Response) (*PostFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFileIdResponse parses an HTTP response from a GetFileIdWithResponse call
func ParseGetFileIdResponse(rsp *http.Response) (*GetFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NoSuchModel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFileResponse parses an HTTP response from a GetFileWithResponse call
func ParseGetFileResponse(rsp *http.Response) (*GetFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFileDeleteResponse parses an HTTP response from a FileDeleteWithResponse call
func ParseFileDeleteResponse(rsp *http.Response) (*FileDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FileDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileDeleted
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseFunctionValidationResponse parses an HTTP response from a FunctionValidationWithResponse call
func ParseFunctionValidationResponse(rsp *http.Response) (*FunctionValidationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FunctionValidationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FunctionValidationResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetModelsResponse parses an HTTP response from a GetModelsWithResponse call
func ParseGetModelsResponse(rsp *http.Response) (*GetModelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetModelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Models
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostTokenResponse parses an HTTP response from a PostTokenWithResponse call
func ParsePostTokenResponse(rsp *http.Response) (*PostTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Token
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthUnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostTokensCountResponse parses an HTTP response from a PostTokensCountWithResponse call
func ParsePostTokensCountResponse(rsp *http.Response) (*PostTokensCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTokensCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokensCount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
